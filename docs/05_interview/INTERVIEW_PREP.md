# 09 - 面试准备完整版

> 针对 AI 芯片公司的面试问答、话术、项目讲解

---

## 📋 目录

1. [项目介绍话术](#1-项目介绍话术)
2. [技术问答 - 架构篇](#2-技术问答---架构篇)
3. [技术问答 - 实现篇](#3-技术问答---实现篇)
4. [技术问答 - 验证篇](#4-技术问答---验证篇)
5. [技术问答 - 优化篇](#5-技术问答---优化篇)
6. [行为问答](#6-行为问答)
7. [反问面试官](#7-反问面试官)
8. [公司针对性准备](#8-公司针对性准备)

---

## 1. 项目介绍话术

### 1.1 30 秒版本 (电梯演讲)

> "我做了一个 **AI 加速器项目**，基于 GitHub 上最火的开源 TPU 项目 (1000+ stars) 进行魔改。
> 
> 添加了三个核心特性：
> 1. **ECC 容错** - Hamming SECDED，符合车规 ASIL-B
> 2. **稀疏化优化** - 零值跳过 + Clock Gating，功耗降低 40%
> 3. **AXI 总线** - 工业级接口，支持 SoC 集成
> 
> 使用 VCS 仿真、UVM 验证、DC 综合，有完整的 PPA 数据。"

### 1.2 2 分钟版本 (详细介绍)

> "我的项目叫 **Titan-TPU V2**，是一个基于 **脉动阵列架构** 的 AI 加速器。
> 
> **项目背景**：
> 我基于 GitHub 上 tiny-tpu-v2 项目（1000+ stars，SystemVerilog 实现）进行深度魔改，
> 目标是打造一个面向车规和边缘计算的高可靠 TPU。
> 
> **核心技术**：
> 1. **Weight Stationary Systolic Array**：8×8 PE 阵列，支持任意大小矩阵乘法
> 2. **ECC SECDED**：使用 Hamming(39,32) 编码，实现单比特纠错、双比特检错
> 3. **Sparse 优化**：检测零值输入/权重，跳过 MAC 计算，并使用 Clock Gating 降低动态功耗
> 4. **AXI4-Lite 接口**：支持 SoC 集成，可与 ARM/RISC-V 处理器配合
> 
> **验证与综合**：
> - VCS 仿真，Verdi 调试
> - UVM 验证环境，功能覆盖率 > 95%
> - DC 综合，目标频率 200MHz，面积约 10 万门
> 
> **量化成果**：
> - ECC 开销：面积 +15%，时序 +5%
> - Sparse 效果：功耗降低 30-40%（稀疏度 50% 时）
> - 峰值算力：25.6 GOPS (8×8 阵列，INT8)
> 
> 这个项目让我深入理解了 AI 加速器的架构设计和验证方法。"

### 1.3 项目亮点总结

| 亮点 | 具体内容 | 面试价值 |
|------|----------|----------|
| **ECC 容错** | Hamming(39,32) SECDED | 海思/海光/车规方向 |
| **Sparse 优化** | 零值跳过 + ICG | NVIDIA/AMD/寒武纪方向 |
| **AXI 接口** | AXI4-Lite Slave | SoC 集成能力 |
| **完整验证** | UVM + 95% 覆盖率 | 验证能力证明 |
| **综合数据** | PPA 量化 | 工程化能力 |

---

## 2. 技术问答 - 架构篇

### Q1: 为什么选择 Systolic Array？

**答案**:
> "选择 Systolic Array 有三个原因：
> 
> **1. 数据复用效率高**
> - 每个数据元素被多个 PE 使用
> - 减少对全局存储器的访问次数
> - 带宽利用率高
> 
> **2. 规则的物理布局**
> - PE 之间只有近邻通信
> - 有利于布局布线
> - 容易实现高频率
> 
> **3. 成熟的工业验证**
> - Google TPU v1-v4 都使用 Systolic Array
> - 是大规模 GEMM 加速的主流方案
> 
> 相比之下，Dataflow 架构灵活性更高但控制复杂，
> 向量处理器通用性好但效率较低。"

### Q2: Weight Stationary vs Output Stationary vs Row Stationary？

**答案**:
> "三种数据流的区别在于**什么数据固定在 PE 中**：
> 
> | 数据流 | 固定数据 | 优势 | 劣势 | 适用场景 |
> |--------|----------|------|------|----------|
> | Weight Stationary | 权重 | 权重复用高 | 部分和移动多 | 推理 |
> | Output Stationary | 部分和 | 减少部分和移动 | 权重移动多 | 训练 |
> | Row Stationary | 行数据 | 平衡复用 | 控制复杂 | 通用 |
> 
> 我选择 **Weight Stationary** 是因为：
> 1. Transformer 推理中，权重矩阵远大于激活
> 2. 权重可以预加载，激活流式处理
> 3. Google TPU v1 也采用这种方式，有工业验证
> 
> 在训练场景下，Output Stationary 可能更优，因为需要频繁更新梯度。"

### Q3: 如何处理大于阵列尺寸的矩阵？

**答案**:
> "通过 **Tiling（分块）** 技术：
> 
> ```
> 假设计算 C[M,N] = A[M,K] × B[K,N]，阵列大小为 8×8
> 
> 1. 将矩阵分块：
>    A 分成 M/8 × K/8 个 8×8 块
>    B 分成 K/8 × N/8 个 8×8 块
> 
> 2. 计算过程：
>    for i in range(M/8):
>        for j in range(N/8):
>            C_tile[i,j] = 0
>            for k in range(K/8):
>                C_tile[i,j] += A_tile[i,k] × B_tile[k,j]  # 阵列计算
> 
> 3. 优化：
>    - 双缓冲：计算当前块时，预加载下一块
>    - 循环展开：减少控制开销
> ```
> 
> 利用率分析：对于 100×100 矩阵
> - 完整块：12×12 = 144 次 8×8 计算
> - 边界块：需要 padding 或特殊处理
> - 理论利用率：约 95%"

### Q4: 为什么不用 GPU？TPU 的优势是什么？

**答案**:
> "**GPU vs TPU 对比**：
> 
> | 维度 | GPU | TPU/专用加速器 |
> |------|-----|----------------|
> | 通用性 | 高 | 低（专注 GEMM）|
> | 能效 | 中 | 高 |
> | 功耗 | 高 (350W) | 低 (<100W) |
> | 编程 | CUDA 灵活 | 固定功能 |
> | 成本 | 高 | 低 |
> 
> **TPU 的优势场景**：
> 1. **边缘推理**：功耗受限，需要高能效
> 2. **大规模部署**：Google 数据中心 TCO 优化
> 3. **特定算子**：GEMM 占比高的模型
> 
> **我的项目定位**：
> 面向车规/边缘场景，功耗 < 100mW，
> 能效比 GPU 高 10 倍以上。"

---

## 3. 技术问答 - 实现篇

### Q5: ECC SECDED 是怎么实现的？

**答案**:
> "我使用 **Hamming(39,32) SECDED** 编码：
> 
> **编码原理**：
> - 32 位数据 + 6 位校验位 + 1 位全局奇偶位 = 39 位
> - SEC (Single Error Correction)：单比特错误可纠正
> - DED (Double Error Detection)：双比特错误可检测
> 
> **校验位计算**（以 P0 为例）：
> ```
> P0 = D[0]^D[1]^D[3]^D[4]^D[6]^D[8]^...
> // 覆盖所有位号最低位为 1 的数据位
> ```
> 
> **检错纠错流程**：
> ```
> 1. 重新计算 syndrome = {P5',P4',P3',P2',P1',P0'}
> 2. 检查全局奇偶位
> 3. 判断：
>    - syndrome=0, parity_ok → 无错误
>    - syndrome≠0, parity_err → 单比特错误，位置=syndrome
>    - syndrome=0, parity_err → 全局奇偶位本身错误
>    - syndrome≠0, parity_ok → 双比特错误（不可纠正）
> ```
> 
> **开销**：
> - 面积增加约 15%（主要是异或树）
> - 延迟增加约 1 个时钟周期
> - 符合 ISO 26262 ASIL-B 要求"

### Q6: Clock Gating 是怎么实现的？

**答案**:
> "我使用 **ICG (Integrated Clock Gating)** 方式：
> 
> **实现代码**：
> ```systemverilog
> module clock_gate (
>     input  logic clk,
>     input  logic enable,
>     input  logic test_enable,  // 测试模式旁路
>     output logic gated_clk
> );
>     logic enable_latch;
>     
>     // 负边沿锁存，避免毛刺
>     always_latch begin
>         if (~clk)
>             enable_latch <= enable | test_enable;
>     end
>     
>     assign gated_clk = clk & enable_latch;
> endmodule
> ```
> 
> **为什么用 Latch？**
> 1. 避免 enable 信号在时钟高电平期间变化产生毛刺
> 2. 在时钟低电平采样 enable，高电平门控
> 3. 这是工业界标准做法
> 
> **在 Sparse PE 中的应用**：
> ```systemverilog
> wire skip_mac = (weight == 0) || (input == 0);
> 
> clock_gate u_icg (
>     .clk(clk),
>     .enable(~skip_mac),  // 非零时使能
>     .test_enable(scan_mode),
>     .gated_clk(mac_clk)
> );
> ```
> 
> **功耗效果**：
> - 动态功耗降低 30-40%（稀疏度 50%）
> - 静态功耗不变"

### Q7: AXI 握手机制是什么？

**答案**:
> "AXI 使用 **VALID/READY 双向握手**：
> 
> ```
>         Master                 Slave
>           │                      │
>           │    VALID=1           │
>           │─────────────────────▶│  Master 发起传输
>           │                      │
>           │    READY=1           │
>           │◀─────────────────────│  Slave 确认接收
>           │                      │
>           │    VALID=1 & READY=1 │
>           │        (握手完成)     │  数据传输发生
> ```
> 
> **关键规则**：
> 1. VALID 可以先于 READY 置高
> 2. VALID 置高后不能撤销（除非 READY 也置高）
> 3. READY 可以依赖 VALID，也可以独立
> 4. 数据传输发生在 VALID && READY 的上升沿
> 
> **我的实现**：
> 采用 **VALID-before-READY** 模式，更简单安全。"

---

## 4. 技术问答 - 验证篇

### Q8: 如何验证 ECC 的正确性？

**答案**:
> "采用 **故障注入测试** 策略：
> 
> ```systemverilog
> // 测试用例 1: 正常数据（无错误）
> task test_no_error();
>     data_in = 32'hDEADBEEF;
>     encoded = encode(data_in);
>     {sec, ded, data_out} = decode(encoded);
>     assert(data_out == data_in);
>     assert(sec == 0 && ded == 0);
> endtask
> 
> // 测试用例 2: 单比特错误（可纠正）
> task test_single_bit_error();
>     for (int i = 0; i < 39; i++) begin
>         encoded_err = encoded ^ (1 << i);  // 翻转第 i 位
>         {sec, ded, data_out} = decode(encoded_err);
>         assert(data_out == data_in);  // 数据应该被纠正
>         assert(sec == 1);              // SEC 标志
>     end
> endtask
> 
> // 测试用例 3: 双比特错误（检测但不纠正）
> task test_double_bit_error();
>     for (int i = 0; i < 38; i++) begin
>         for (int j = i+1; j < 39; j++) begin
>             encoded_err = encoded ^ (1 << i) ^ (1 << j);
>             {sec, ded, data_out} = decode(encoded_err);
>             assert(ded == 1);  // DED 标志
>         end
>     end
> endtask
> ```
> 
> **覆盖率**：
> - 所有 39 个单比特位置
> - 所有 741 个双比特组合（C(39,2)）
> - 边界值：全 0、全 1、交替 pattern"

### Q9: UVM 环境是怎么搭建的？

**答案**:
> "我的 UVM 环境包含以下组件：
> 
> ```
> ┌─────────────────────────────────────────────────────────────┐
> │                      tpu_test                               │
> └───────────────────────────┬─────────────────────────────────┘
>                             │
> ┌───────────────────────────▼─────────────────────────────────┐
> │                      tpu_env                                │
> │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
> │  │  tpu_agent  │  │  tpu_agent  │  │    scoreboard       │ │
> │  │   (master)  │  │   (slave)   │  │                     │ │
> │  │ ┌─────────┐ │  │ ┌─────────┐ │  │  golden_model.py    │ │
> │  │ │ driver  │ │  │ │ driver  │ │  │         ↓           │ │
> │  │ │ monitor │ │  │ │ monitor │ │  │     compare         │ │
> │  │ │ seqr    │ │  │ │         │ │  │                     │ │
> │  │ └─────────┘ │  │ └─────────┘ │  └─────────────────────┘ │
> │  └─────────────┘  └─────────────┘                          │
> └─────────────────────────────────────────────────────────────┘
> ```
> 
> **关键组件**：
> 1. **Sequence**：生成随机矩阵数据
> 2. **Driver**：驱动 DUT 接口
> 3. **Monitor**：采集输出
> 4. **Scoreboard**：与 Golden Model 比对
> 5. **Coverage**：功能覆盖率收集
> 
> **覆盖率目标**：
> - 功能覆盖率 > 95%
> - 代码行覆盖率 > 90%
> - FSM 状态覆盖率 100%"

---

## 5. 技术问答 - 优化篇

### Q10: 利用率为什么不是 100%？

**答案**:
> "利用率损失主要来自三个方面：
> 
> **1. 矩阵边界 (Padding)**
> - 矩阵维度不能被阵列尺寸整除
> - 例如：100×100 矩阵用 8×8 阵列
> - Padding 到 104×104，利用率 = 100²/104² = 92.5%
> 
> **2. Pipeline Bubble**
> - 启动阶段：数据填充阵列需要 N-1 周期
> - 排空阶段：结果输出需要 N-1 周期
> - 对于小矩阵，bubble 占比高
> 
> **3. Sparse 跳过**
> - 零值跳过会降低有效计算周期
> - 但这是功耗优化的 trade-off
> 
> **优化措施**：
> 1. 批处理：多个小矩阵合并
> 2. 循环展开：减少控制开销
> 3. 双缓冲：计算和加载重叠"

### Q11: 如何将性能提升 2 倍？

**答案**:
> "有多种方法：
> 
> **1. 阵列扩展** (最直接)
> - 从 8×8 扩展到 16×16
> - 算力提升 4 倍，但面积也增加
> 
> **2. 频率提升**
> - 优化关键路径，提高频率
> - 需要更深的流水线
> 
> **3. 数据精度优化**
> - INT8 → INT4：算力翻倍
> - 需要量化训练支持
> 
> **4. 双 Systolic Array**
> - 两个阵列并行工作
> - 适合大 batch 推理
> 
> **5. 指令优化**
> - 更好的 Tiling 策略
> - 减少数据搬运开销
> 
> **最推荐**：阵列扩展 + 频率优化组合"

---

## 6. 行为问答

### Q12: 遇到最难的 Bug 是什么？

**答案**:
> "最难的 Bug 是 **PE 模块的多驱动问题**。
> 
> **现象**：
> VCS 编译报错 `Error-[ICPD] Illegal combination of drivers`，
> `weight_reg_active` 被 `always_comb` 和 `always_ff` 同时驱动。
> 
> **分析过程**：
> 1. 阅读错误信息，定位到 pe.sv 第 52-58 行
> 2. 发现原作者想实现组合逻辑选择 + 时序逻辑更新
> 3. 但 SystemVerilog 不允许同一信号有多个驱动源
> 
> **解决方案**：
> ```systemverilog
> // 修复前：两个 always 块驱动同一信号
> always_comb: weight_reg_active = mux_select ? ... : ...
> always_ff:   weight_reg_active <= new_value
> 
> // 修复后：统一到 always_ff
> always_ff @(posedge clk) begin
>     if (rst)
>         weight_reg_active <= 0;
>     else if (switch)
>         weight_reg_active <= weight_reg_shadow;
>     // 其他情况保持不变
> end
> ```
> 
> **学到的教训**：
> 1. 一个信号只能有一个驱动源
> 2. 组合逻辑和时序逻辑要分清
> 3. 开源代码也可能有 Bug，要批判性使用"

### Q13: 为什么选择这个项目？

**答案**:
> "选择这个项目有三个原因：
> 
> **1. 技术价值**
> - AI 加速器是芯片行业热点
> - Systolic Array 是核心架构，值得深入学习
> - 涵盖 RTL、验证、综合全流程
> 
> **2. 职业发展**
> - 海思、寒武纪、地平线等都在招 NPU 设计
> - 掌握这个技术栈能增加竞争力
> - 从入门到进阶有清晰路径
> 
> **3. 个人兴趣**
> - 我对计算机体系结构有浓厚兴趣
> - 喜欢从底层理解 AI 是如何被加速的
> - 希望能在这个领域长期发展"

---

## 7. 反问面试官

### 技术相关
1. "贵司的 NPU/TPU 采用什么数据流架构？Weight Stationary 还是其他？"
2. "验证团队规模多大？使用什么 EDA 工具和方法学？"
3. "是否有自研编译器？和硬件团队如何协作？"

### 团队相关
4. "新人的培养路径是怎样的？"
5. "团队使用什么协作工具和流程？"
6. "技术分享和学习的机会多吗？"

### 项目相关
7. "目前团队在做什么项目？我可能参与哪个方向？"
8. "芯片的目标应用场景是什么？"
9. "最近有什么技术挑战？"

---

## 8. 公司针对性准备

### 8.1 海思 / 海光 (ECC 重点)

**强调点**：
- ECC SECDED 实现细节
- 车规 ASIL 要求
- 高可靠性设计

**准备问题**：
- "SECDED 的编解码延迟是多少？"
- "如何处理不可纠正的双比特错误？"
- "ECC 对系统性能的影响？"

### 8.2 NVIDIA / AMD (Sparse 重点)

**强调点**：
- Sparse 优化效果
- Clock Gating 实现
- 功耗分析数据

**准备问题**：
- "和 Ampere 的 2:4 稀疏化有什么区别？"
- "如何处理非结构化稀疏？"
- "动态功耗降低多少？"

### 8.3 寒武纪 / 地平线 (全栈)

**强调点**：
- 完整系统设计能力
- 端到端验证
- 性能分析

**准备问题**：
- "如何支持不同的神经网络算子？"
- "编译器如何做 Tiling 优化？"
- "和 GPU 相比的能效比？"

---

*文档版本: v1.0 | 更新时间: 2025-01-16*
